using these refrence code that i am going to give you ....i want you to give me the nextjs api endpoint and tenstack react query hook that is similar with the refrence code that i would give you .....the nextjs api endpoint returns all the questions for a particular subject of a particular examid that it would recieve as a searchParams
use these code i would give you below as refrence codes....the nextjs api endpoint should contains async GET as it is in the refrence code and in nextjs 13.4 app router and also how it used return NextResponse.json  and the tenstack react query hook that would query and return the data make sure it is 
strictly typed with typescript and that it has the queryKey and queryFn as in the refrence code and also do not forget how it used usesuspensquery and usesuspensequeryresult ...and also do not forget to use kv vercel kv redis for caching the values and how it was used in the refrence code that i gave you 
// hooks/useExamStatus.ts
import { ExamStatus } from '@/app/api/exam-status/aside-functions';
import { UseSuspenseQueryResult, useSuspenseQuery } from '@tanstack/react-query';
import { addBaseURL } from '../addBaseUrl';
// types/ExamStatusTypes.ts


export interface ExamStatusResponse {
    status: ExamStatus;
    examDate?: Date;
    length?: number;
}

async function fetchExamStatus({ queryKey }: { queryKey: [string, string] }): Promise<ExamStatusResponse> {
    const [, classLevel] = queryKey;
    const url = addBaseURL(`/api/exam-status?classLevel=${classLevel}`);
    const response = await fetch(url);

    if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error);
    }
    return response.json();
}


export function useExamStatus(classLevel: 'jss1' | 'ss1'): UseSuspenseQueryResult<ExamStatusResponse, Error> {
    return useSuspenseQuery({
        queryKey: ['examStatus', classLevel],
        queryFn: fetchExamStatus,
        staleTime: 1000 * 60 * 60 * 24,
        // 24 hours

    });
}
and
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DIRECT_URL")
  // directUrl = env("DATABASE_URL")
}

model UserAuth {
  id                    String   @id @unique @default(cuid())
  email                 String   @unique
  firstName             String
  lastName              String
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  username              String?
  imageUrl              String?
  banned                Boolean
  primaryEmailAddressId String?
  primaryPhoneNumberId  String?
  emailAddresses        Json
  phoneNumbers          Json
  userId                String   @unique
  user                  User?
}

model User {
  id                            String       @id @unique @default(cuid())
  name                          String
  officialEmail                 String       @unique
  class                         String
  dob                           DateTime
  officialPhoneOrWhatsappNumber String
  fullAddress                   String
  locality                      String
  city                          String
  state                         String
  country                       String
  homeAddress                   String
  role                          Role         @default(STUDENT)
  classLevel                    ClassLevel // Add this line
  result                        Result?
  userAnswer                    UserAnswer[]
  userExam                      UserExam[]
  userAuthId                    String       @unique
  userAuth                      UserAuth?    @relation(fields: [userAuthId], references: [id])
}

model Exam {
  id                      String                   @unique
  date                    DateTime
  startTime               DateTime?
  lengthOfExam            Int?
  classLevel              ClassLevel // Add this line
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  englishQuestions        EnglishQuestion[]
  generalStudiesQuestions GeneralStudiesQuestion[]
  mathQuestions           MathQuestion[]
  userExam                UserExam[]
}

model UserExam {
  id        String
  userId    String
  examId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  examFinished Boolean @default(false)
  resultId     String? @unique
  exam         Exam    @relation(fields: [examId], references: [id])
  result       Result? @relation(fields: [resultId], references: [id])
  user         User    @relation(fields: [userId], references: [id])

  @@unique([userId, examId])
}

model Instructions {
  id           Int      @id @default(1)
  instructions Json
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model EnglishQuestion {
  id             String   @id @unique @default(cuid())
  questionNumber Int      @unique
  question       String
  optionA        String
  optionB        String
  optionC        String
  optionD        String
  correctAnswer  Option
  studentAnswer  Option?
  examId         String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  exam           Exam     @relation(fields: [examId], references: [id])
}

model UserAnswer {
  id             String   @id @unique @default(cuid())
  userId         String
  questionId     Int
  answer         Option
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  questionNumber Int
  subject        String
  user           User     @relation(fields: [userId], references: [id])

  @@unique([userId, questionId])
}

model MathQuestion {
  id             String   @id @unique @default(cuid())
  questionNumber Int      @unique
  question       String
  optionA        String
  optionB        String
  optionC        String
  optionD        String
  correctAnswer  Option
  studentAnswer  Option?
  examId         String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  exam           Exam     @relation(fields: [examId], references: [id])
}

model GeneralStudiesQuestion {
  id             String   @id @unique @default(cuid())
  questionNumber Int      @unique
  question       String
  optionA        String
  optionB        String
  optionC        String
  optionD        String
  correctAnswer  Option
  studentAnswer  Option?
  examId         String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  exam           Exam     @relation(fields: [examId], references: [id])
}

model Notification {
  id        String   @id @unique @default(cuid())
  message   String
  date      DateTime
  seen      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Result {
  id                  String    @id @unique @default(cuid())
  englishScore        Int
  mathsScore          Int
  generalStudiesScore Int
  totalScore          Int
  aggregate           Float
  position            Int
  passed              Boolean
  userId              String    @unique
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  userExamId          Int       @unique
  user                User      @relation(fields: [userId], references: [id])
  userExam            UserExam?
}

enum Option {
  A
  B
  C
  D
}

enum Role {
  STUDENT
  ADMIN
  SUPERADMIN
}

enum ClassLevel {
  JSS1
  SS1
}
and
type KVOperation<T> = () => Promise<T>;

// Helper function to perform KV operations safely
export async function safeKVOperation<T>(operation: KVOperation<T>): Promise<T | null> {
    try {
        const result = await operation();
        console.log('KV operation successful:', result);
        return result;
    } catch (error) {
        console.error('KV operation error:', error);
        // Return null to indicate the operation did not succeed
        return null;
    }
}
// lib/cacheHandlers.ts

import { kv } from '@vercel/kv';
import { safeKVOperation } from '../../safeKvOperation';
import { ExamStatus } from './route';

export async function getExamStatusCache(cacheKey: string): Promise<ExamStatus[] | null> {
    return safeKVOperation(() => kv.get(cacheKey));
}

export const setExamStatusCache = async (cacheKey: string, data: any) => {
    return safeKVOperation(() => kv.set(cacheKey, data, { ex: 60 * 60 * 24 }));
};

export const deleteExamStatusCache = async (cacheKey: string) => {
    return safeKVOperation(() => kv.del(cacheKey));
};
// pages/api/exam-status.ts

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { deleteExamStatusCache, getExamStatusCache, setExamStatusCache } from './cache';
import { Exam } from '@prisma/client';
// types/ExamStatusTypes.ts

export enum ExamStatusEnum {
    NoExamYet = 'NO_EXAM_YET',
    ExamData = 'EXAM_DATA',
}

import { Exam as PrismaExam, EnglishQuestion, GeneralStudiesQuestion, MathQuestion, UserExam } from '@prisma/client';

export type ExamStatus = {
    exam: {
        id: PrismaExam['id'];
        classLevel: PrismaExam['classLevel'];
        date: PrismaExam['date'];
        startTime: PrismaExam['startTime'];
        lengthOfExam: PrismaExam['lengthOfExam'];
        englishQuestions: Array<{ id: EnglishQuestion['id'] }>;
        generalStudiesQuestions: Array<{ id: GeneralStudiesQuestion['id'] }>;
        mathQuestions: Array<{ id: MathQuestion['id'] }>;
        userExam: Array<{ id: UserExam['id'] }>;
    };
    englishQuestionsCount: number;
    generalStudiesQuestionsCount: number;
    mathQuestionsCount: number;
    usersWritingExamCount: number;
};

export async function GET(req: NextRequest): Promise<NextResponse> {
    const revalidate = req.nextUrl.searchParams.get('revalidate') === 'true';
    const cacheKey = 'tica:exam-status';

    try {
        if (revalidate) {

            console.log('Revalidating cache: deleting and fetching fresh data');
            await deleteExamStatusCache(cacheKey);
        }

        // Define a type for the exam status object

        // Use the type for the examStatus variable
        let examStatus: ExamStatus[] | null = revalidate ? null : await getExamStatusCache(cacheKey);


        if (!examStatus) {
            console.log('Fetching exam status from database');
            const exams = await prisma.exam.findMany({
                select: {
                    id: true,
                    classLevel: true,
                    date: true,
                    startTime: true,
                    lengthOfExam: true,

                    // Replace with actual fields you need from the exam
                    englishQuestions: {
                        select: {
                            id: true, // Replace with actual fields you need from englishQuestions
                        }
                    },
                    generalStudiesQuestions: {
                        select: {
                            id: true, // Replace with actual fields you need from generalStudiesQuestions
                        }
                    },
                    mathQuestions: {
                        select: {
                            id: true, // Replace with actual fields you need from mathQuestions
                        }
                    },
                    userExam: {
                        select: {
                            id: true, // Replace with actual fields you need from userExam
                        }
                    },
                },
            });

            if (exams.length === 0) {
                console.log('No exams found');
                return NextResponse.json({ status: ExamStatusEnum.NoExamYet });
            }

            examStatus = exams.map(exam => ({
                exam: exam,
                englishQuestionsCount: exam.englishQuestions.length,
                generalStudiesQuestionsCount: exam.generalStudiesQuestions.length,
                mathQuestionsCount: exam.mathQuestions.length,
                usersWritingExamCount: exam.userExam.length,
            }));

            await setExamStatusCache(cacheKey, examStatus);
        }

        return NextResponse.json({ status: ExamStatusEnum.ExamData, data: examStatus });
    } catch (error) {
        console.error('Error fetching exam status:', error);
        return NextResponse.json({ error: 'Error fetching exam status' }, { status: 500 });
    }
}



